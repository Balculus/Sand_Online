---
layout: post
title: Linux 进程
date: 2022-11-30
author: 来自第一世界
tags: [Linux]
comments: false
---
记录 Linux 学习过程中需要总结的点



### 进程状态

* D：不可中断的深度睡眠 状态 ，处于这种状态 的进程 不 能响应异步信号；
* R：进程处于运行 态 或就绪状态 只有在该状态的进程才可能在 CPU 上运行。而同一时刻可能有多个进程处于可执行状态；
* S：可中断 的睡眠状态，处于这个状态的进程因为等待某种 事件的发生而被挂起；
* T：暂停状态或跟踪状态
* X：退出状态，进程即将被销毁
* Z：退出状态，进程成为僵尸进程 。

### 进程操作

fork() 函数用于创建进程，将运行着的进程分裂出另一个子进程，它通过拷贝父进程的方式创建子进程。如果成功创建了进程，会对父子进程各返回一次，其中对父进程返回子进程的 PID，对子进程返回 0；失败返回小于0的错误码。

进程终止可分为正常终止和异常终止两大类，其中常见正常终止方式的有：

* 从 `main() `函数 return 返回；
* 调用类 `exit()` 函数。

常见的异常终止方式有：

* 调用 `abort()` 函数；
* 接收到一个信号终止。

exec 族函数用来替换调用进程的执行程序。

`fork()` 在创建进程后子进程与父进程有相同的代码空间；而实际应用中，子进程往往需要执行另一个程序，这种情况下，可以在子进程中调用 exec 族函数将此进程的执行程序完全替换为新程序，并从新进程的 main 函数开始执行。

exec族函数有6个不同的exec函数，函数原型分别如下：

```c
#include 
extern char **environ;
int execl(co nst char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg,..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const arg v[]);
int execvpe(const char *file, char *const argv[],char *const envp[]);
```

* 后缀 p：表示使用 filename 做参数，如果 filename 中包含“/”，则视为路径名，否则在 PATH 环境变量所指定的各个目录中搜索可执行文件，如 `execlp()` 函数。无后缀 p 则使用路径名来指定可执行文件的位置，如 `execl()` 函数。
* 后缀 e：表示可以传递一个指向环境字符串指针数组的指针，环境数组需要以 NULL 结束，如 execvpe() 函数。而无此后缀的函数则使用调用进程中 environ 变量为新程序复制现有的环境，如 `execv()` 函数。
* 后缀 l：表示使用 list 形式来传递新程序的参数，传给新程序的所有参数以可变参数的形式从 exec 给出，最后一个参数需要为NULL以表示结束，如 `execl()` 函数。
* 后缀 v：表示使用 vector 形式来传递新程序的参数，传给新程序的所有参数放入一个字符串数组中，数组以 NULL 结束以表示结束，如 `execv()` 函数

exec族函数只有在出错的时候才会返回，如果成功，该函数无返回，否则返回-1。

`wait()` 函数用来帮助父进程获取其子进程的退出状态 。当进程退出时，内核为每一个进程保存了一定量的退出状态信息，父进程可根据此退出信息来判断子进程的运行状况。如果父进程未调用 `wait()` 函数，则子进程的退出信息将一直保存在内存中。

由于进程终止的异步性，可能会出现子进程先终止或者父进程先终止的情况，从而出现两种特殊的进程：

* 僵尸进程：如果子进程先终止，但其父进程未为其调用 `wait()` 函数，那么该子进程就变为僵尸进程。僵尸进程在它父进程为它调用 `wait()` 函数之前将一直占有系统的内存资源。
* 孤儿进程：如果父进程先终止，尚未终止的子进程将会变成孤儿进程。孤儿进程将直接被 init 进程收管，由 init 进程负责收集它们的退出状态。
